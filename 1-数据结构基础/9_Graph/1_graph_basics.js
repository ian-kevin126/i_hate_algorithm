/**
 * 图：图是网络结构的抽象模型，是一组由边连接的节点。图可以表示任何二元关系，比如道路、航班等...
 *
 * JavaScript中没有图这个数据结构，但是可以用object和array来构建图。
 *
 * 图的表示法：邻接矩阵、邻接表、关联矩阵等
 *
 *                           A  ——>  B  ——>  C
 *                            ↖   ↙      ↙
 *                               D  <——  E
 *
 * 邻接矩阵：
 *  - 有关联的置为 1
 *  - 没有关联的置为 0
 *
 *                                A  B  C  D  E
 *                           --|----------------|
 *                           A |  0  1  0  0  0 |
 *                           B |  0  0  1  1  0 |
 *                           C |  0  0  0  0  1 |
 *                           D |  1  0  0  0  0 |
 *                           E |  0  0  0  1  0 |
 *                           --|----------------|
 *
 * 邻接表：其实就是一个对象，还可以用链表来表示
 *
 *       {
 *          A: ["B"],
 *          B: ["C", "D"],
 *          C: ["E"],
 *          D: ["A"],
 *          E: ["D"],
 *       }
 *
 * 图的常见操作：
 *  - 深度优先遍历
 *  - 广度优先遍历
 *
 */

const graphData = {
  0: [1, 2],
  1: [2],
  2: [0, 3],
  3: [3],
};

/**
 * 图的深度优先遍历（递归版）：尽可能深的搜索图的分支
 *
 *  - 1、访问根节点
 *  - 2、对根节点的 ”没访问过的相邻节点“ 挨个进行深度优先遍历
 */

// 设置一个记录访问过的节点的集合，如果已经访问过的节点我们就不再访问（见第2步）
const visited = new Set();
const graph_DFS = (n) => {
  // 1、访问根节点
  console.log(n);
  visited.add(n);
  graphData[n].forEach((c) => {
    // 2、对根节点的 ”没有访问过的相邻节点“ 挨个进行深度优先遍历
    if (!visited.has(c)) {
      graph_DFS(c);
    }
  });
};

graph_DFS(2); // 2 0 1 3

/**
 * 图的广度优先遍历（递归版）：先访问离根节点最近的节点
 *
 *  - 1、新建一个队列，把根节点入队
 *  - 2、把队头出队并访问
 *  - 3、把队头的 “没访问过的相邻节点” 入队
 *  - 4、重复第二、三步，直到队列为空
 */

const _visited = new Set();

const graph_BFS = (n) => {
  // 1、新建一个队列，把根节点入队
  _visited.add(n);
  const q = [n];
  // 4、重复执行第二、三步
  while (q.length) {
    // 2、把队头出队并访问
    const n = q.shift();
    console.log(n);

    graphData[n].forEach((c) => {
      // 3、把队头的 “没访问过的相邻节点” 入队
      if (!_visited.has(c)) {
        q.push(c);
        _visited.add(c);
      }
    });
  }
};

graph_BFS(2); // 2 0 3 1
